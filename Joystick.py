# encoding: utf-8


# DOWNLOAD PS3 DRIVER FROM A SAFE SITE https://sourceforge.net/projects/scptoolkit.mirror/
# OR USE THE DRIVERS IN THE CURRENT PROJECT SCP-DS-Driver-Package-1.2.0.160 (COMPATIBLE 32 & 64 bits)
# BUILD THE CYTHON CODE FROM COMMAND LINE:
# C:\>python setup_project.py build_ext --inplace

# REQUIREMENT
# Cython	0.29.21	0.29.21
# llvmlite	0.34.0	0.34.0
# numba	0.51.2	0.51.2
# numpy	1.19.3	1.19.4
# opencv-python	4.4.0.46	4.4.0.46
# pip	20.2.4	20.2.4
# pygame	2.0.0	2.0.0
# scipy	1.5.4	1.5.4
# setuptools	50.3.2	50.3.2

__version__ = 1.00
__author__  = "Yoann Berenguer"

# TODO get.instance_id will failed with SLD <2.0
# TODO get_guid will failed with SLD <2.0

"""

When compiled with SDL2, pygame has these additional events and their attributes.

AUDIODEVICEADDED   which, iscapture
AUDIODEVICEREMOVED which, iscapture
FINGERMOTION       touch_id, finger_id, x, y, dx, dy
FINGERDOWN         touch_id, finger_id, x, y, dx, dy
FINGERUP           touch_id, finger_id, x, y, dx, dy
MOUSEWHEEL         which, flipped, x, y
MULTIGESTURE       touch_id, x, y, pinched, rotated, num_fingers
TEXTEDITING        text, start, length
TEXTINPUT          text
WINDOWEVENT        event

SDL2 supports controller hotplugging:

CONTROLLERDEVICEADDED    device_index
JOYDEVICEADDED           device_index
CONTROLLERDEVICEREMOVED  instance_id
JOYDEVICEREMOVED         instance_id
CONTROLLERDEVICEREMAPPED instance_id

The following event types will be generated by the joysticks

JOYAXISMOTION JOYBALLMOTION JOYBUTTONDOWN JOYBUTTONUP JOYHATMOTION
And in pygame 2, which supports hotplugging:

JOYDEVICEADDED JOYDEVICEREMOVED
Note that in pygame 2, joysticks events use a unique "instance ID".
The device index passed in the constructor to a Joystick object is not unique 
after devices have been added and removed. You must call Joystick.get_instance_id()
to find the instance ID that was assigned to a Joystick on opening.
"""

# CYTHON MODULE SOUNDSERVER
from pygame.joystick import Joystick
from pygame.transform import smoothscale

try:
    from SoundServer import SoundControl
except ImportError:
    raise ImportError("\nCython library SoundServer is missing or not cynthonized!")
# CYTHON MODULE SPRITES
try:
    from Sprites import Sprite, LayeredUpdatesModified
except ImportError:
    raise ImportError("\nCython library Sprite is missing or not cynthonized!")
try:
    import pygame
    from pygame import freetype
    from pygame.mixer import Sound
    from pygame.math import Vector2
    from pygame.freetype import Font, STYLE_NORMAL
    from pygame import Rect, SWSURFACE, SRCALPHA
except ImportError:
    raise ImportError("\nLibrary pygame is not install on your system, try:\nC:\\>pip install pygame")

try:
    import numpy
except ImportError:
    raise ImportError("\nLibrary numpy is not install on your system, try:\nC:\\>pip install numpy")

import _pickle as pickle
import os
from os import environ
import sys
import platform
import re

try:
    from Constants import CONSTANTS
except ImportError:
    raise ImportError("\nCython library Constants is missing or not cynthonized!")


GL = CONSTANTS()


def set_video():
    """

    :return:
    """
    try:
        # THIS MIGHT FAILED TO INIT IF VARIABLE SDL_VIDEODRIVER IS SET TO WINDIB OR DIRECTX
        screen = pygame.display.set_mode((GL.SCREENRECT_W, GL.SCREENRECT_H),
                                         GL.VIDEO_FLAGS, GL.SCREEN_BIT_DEPTH)
    except pygame.error:
        try:
            environ['SDL_VIDEODRIVER'] = ""
            screen = pygame.display.set_mode((GL.SCREENRECT_W, GL.SCREENRECT_H),
                                             GL.VIDEO_FLAGS, GL.SCREEN_BIT_DEPTH)
        except:
            raise Exception('\nPygame cannot initialized the video mode.')

    return screen


set_video()


try:
    from JoystickLayout import CONTROLLER_LAYOUT, OPTIONS_MENU_JOYSTICK
except ImportError:
    raise ImportError("\nCython library JoystickLayout is missing or not cynthonized!")

from Textures import XBOX_IMAGE, PS4_IMAGE, PS3_IMAGE, RED_SWITCH1, PS3_BACKGROUND, RED_SWITCH2, \
    PURPLE_FLAG, BLUE_FLAG, RED_FLAG, GREEN_FLAG, RED_SWITCH3, \
    XBOX_BACKGROUND, PS4_BACKGROUND, WHITE_FLAG


class JoystickEmulator(Sprite): pass
class Focus(Sprite): pass


class Focus(Sprite):

    def __init__(self, parent_: JoystickEmulator, images_: list,
                 x: int, y: int, timing_: float, layer_: int = 0):
        """
        DISPLAY A CIRCULAR EFFECT AROUND A FOCUS POINT (BUTTON, HATS, JOYSTICK BEING PRESSED)

        :param parent_: object; Parent object. Stop the sprite animation if the parent
         does no longer exist (killed)
        :param images_: list of pygame.Surface (animation). Can be one of the
        following PURPLE_FLAG, BLUE_FLAG, RED_FLAG, GREEN_FLAG
        :param x: integer; x position (focus position x)
        :param y: integer; y position (focus position y)
        :param timing_: float; time interval between each frames (in ms)
        :param layer_: integer; Layer level
        """
        assert isinstance(parent_, JoystickEmulator), \
            '\nArgument parent_ must be a JoystickEmulator instance got %s ' % type(parent_)
        assert isinstance(images_, list), "\nArgument images_ must be a python list got %s " % type(images_)
        assert isinstance(x, int), "\nArgument x must be an integer got %s " % type(x)
        assert isinstance(y, int), "\nArgument y must be an integer got %s " % type(y)
        assert isinstance(timing_, float), "\nArgument timing_ must be a float got %s " % type(timing_)
        assert isinstance(layer_, int), "\nArgument layer_ must be an int got %s " % type(layer_)
        assert isinstance(GL, CONSTANTS), \
            "\nGL (Global constants/variables) must be an instance of CONSTANTS class got %s " % type(GL)
        assert hasattr(GL, 'ALL'), "\nGL instance is missing attribute ALL"
        assert hasattr(GL, "TIME_PASSED_SECONDS"), "\nGL instance is missing attribute TIME_PASSED_SECONDS"

        Sprite.__init__(self, GL.ALL)

        if isinstance(GL.ALL, LayeredUpdatesModified):
            GL.ALL.change_layer(self, layer_)

        self.gl          = GL
        self.images_copy = images_.copy()
        self.image       = self.images_copy[0]
        self.rect        = self.image.get_rect(center=(x, y))
        self.x           = x
        self.y           = y
        self._blend      = 0
        self.dt          = 0
        self.index       = 0
        self.timing      = timing_
        self.length      = len(self.images_copy) - 1
        self.parent      = parent_
        if not self.parent.alive():
            self.kill()
            return
        else:
            self.update()

        if not self.parent.connected:
            self.kill()
            return

    def update(self) -> None:
        """
        PYGAME UPDATE METHOD
        THIS FUNCTION IS CALL EVERY FRAMES FROM THE MAIN LOOP
        THE LOCAL REFRESHING RATE IS SET WITH THE VARIABLE self.timing
        """
        # CHECK IF THE PARENT OBJECT IS STILL ALIVE
        if not self.parent.alive():
            self.kill()
            return

        # STOP ANIMATION IF THE PARENT JOYSTICK IS DISCONNECTED
        if not self.parent.connected:
            self.kill()
            return

        if self.dt >= self.timing:

            self.image = self.images_copy[self.index]
            # RE-CENTRE THE SPRITE
            self.rect  = self.image.get_rect(center=(self.x, self.y))

            if self.index < self.length:
                self.index += 1
            else:
                self.kill()

            self.dt = 0

        self.dt += GL.TIME_PASSED_SECONDS


class JoystickEmulator(Sprite):

    def __init__(self, gl_: CONSTANTS, model_: dict, menu_position_: tuple,
                 offset_: tuple, layer_: int = 0, timing_: float = 120.0):

        assert isinstance(gl_.ALL, LayeredUpdatesModified),\
            'gl_.ALL should be a LayeredUpdatesModified class.'
        assert isinstance(model_, dict), 'model_ must be a python dictionary got %s ' % type(model_)
        assert isinstance(menu_position_, tuple), \
            'Argument menu_position_ must be a tuple got %s ' % type(menu_position_)
        assert isinstance(offset_, tuple), 'Argument offset_ must be a tuple got %s ' % type(offset_)
        assert isinstance(layer_, int), 'Argument layer_ must be an integer got %s ' % type(layer_)
        assert isinstance(timing_, float), 'Argument timing_ must be an float got %s ' % type(timing_)
        assert isinstance(gl_, CONSTANTS), \
            "\nGL (Global constants/variables) must be an instance of CONSTANTS class got %s " % type(gl_)
        assert hasattr(gl_, 'ALL'), "\ngl_ instance is missing attribute ALL"
        assert hasattr(gl_, "TIME_PASSED_SECONDS"), "\ngl_ instance is missing attribute TIME_PASSED_SECONDS"

        assert isinstance(OPTIONS_MENU_JOYSTICK, dict), \
            "\nOPTIONS_MENU_JOYSTICK must be a python dict type got %s " % type(OPTIONS_MENU_JOYSTICK)

        Sprite.__init__(self, gl_.ALL)

        if isinstance(gl_.ALL, LayeredUpdatesModified):
            gl_.ALL.change_layer(self, layer_)

        self.layer_        = layer_
        self.gl            = gl_
        self.menu_position = menu_position_
        self.offset        = offset_
        self.layer_        = layer_
        self.timing        = timing_
        self.dt            = 0
        self.force_kill    = False
        self.index         = 0
        self.model         = model_

        self.w, self.h = 700, 500
        self.image = pygame.Surface((self.w, self.h), depth=32, flags=(SWSURFACE | SRCALPHA))

        assert isinstance(model_['bck'], pygame.Surface),\
            "\nmodel_ dictionary key 'bck' must be pygame.Surface got %s " % type(model_['bck'])
        model_['bck'] = smoothscale(model_['bck'], (self.w, self.h))

        # self.image.fill((50, 62, 65, 100))
        self.image.blit(model_['bck'], (0, 0))
        assert isinstance(model_['image'], pygame.Surface), \
            "\nmodel_ dictionary key 'image' must be pygame.Surface"
        model_['image'].set_alpha(255)

        self.image.blit(model_['image'], (self.offset[0], self.offset[1]))
        self.rect = self.image.get_rect(topleft=(menu_position_[0], menu_position_[1]))
        self.image.set_alpha(220)
        self.images_copy = self.image.copy()

        assert isinstance(CONTROLLER_LAYOUT, dict), \
            "\nCONTROLLER_LAYOUT must be a python dict type got %s " % type(CONTROLLER_LAYOUT)

        try:
            self.buttons = CONTROLLER_LAYOUT[self.model['model name']]['buttons']
            self.axes    = CONTROLLER_LAYOUT[self.model['model name']]['axis']
            self.hats    = CONTROLLER_LAYOUT[self.model['model name']]['hats']
        except (ValueError, KeyError, IndexError) as error:
            raise Exception('\nController layout is not formatted correctly, error %s ') % error

        self.offset_x   = int(self.menu_position[0] + self.offset[0])
        self.offset_y   = int(self.menu_position[1] + self.offset[1])
        self.red        = (255, 0, 0, 255)
        self.white      = (255, 255, 255, 255)
        self.connected  = True
        self.exit_rect  = RED_SWITCH1.get_rect(
            topleft=(self.menu_position[0] + self.w - RED_SWITCH1.get_width(),
                     self.menu_position[1]))
        self.exit_rect  = self.exit_rect.inflate(-15, -17)

        joystick_bind = model_["object"]
        try:

            joystick_bind.init()

        except pygame.error:
            self.destroy()

        # COMPATIBLE FOR PYGAME >= 2.0
        if pygame.version.ver[0] >= "2":
            self.my_joystick = {"NAME"       : joystick_bind.get_name(),
                                "GUID"       : joystick_bind.get_guid(),
                                "INSTANCE_ID": joystick_bind.get_instance_id(),
                                "ID"         : joystick_bind.get_id()}
        else:
            # COMPATIBLE PYGAME < 2.0
            self.my_joystick = {"NAME"       : joystick_bind.get_name(),
                                "GUID"       : None,
                                "INSTANCE_ID": None,
                                "ID"         : joystick_bind.get_id()}

        print("\nJoystick detected : ", self.my_joystick, self.model["id"])

    def highlight(self, images_: list, coordinates_: tuple) -> None:
        """
        CONVENIENT HOOK TO THE CLASS Focus

        :param images_: list of pygame surface to use for the animation
        :param coordinates_: tuple (x, y) position values for the focus
        :return: None
        """
        Focus(parent_=self, images_=images_, x=int(coordinates_[0]),
              y=int(coordinates_[1]), timing_=1.0, layer_=self.layer_)

    def tick_sound(self) -> None:
        """
        PLAY A TICK SOUND WHENEVER A JOYSTICK BUTTON IS PRESSED
        PYGAME MIXER HAS TO BE INITIALIZED PRIOR CALLING THIS METHOD

        :return: None
        """
        if self.gl.TICK_SOUND:
            if pygame.mixer.get_init() is not None:
                self.gl.SOUND_SERVER.play(
                    sound_=MOUSE_CLICK_SOUND, loop_=False, priority_=0,
                    volume_=self.gl.SOUND_LEVEL, fade_in_ms=100, fade_out_ms=100,
                    panning_=False, name_='JOYSTICK BUTTON PRESSED')

    def display_joystick_connection_status(self) -> None:
        """
        DISPLAY THE JOYSTICK CONNECTION STATUS ON THE TOP OF THE WINDOW

        :return: Npne
        """

        w, h = self.image.get_size()

        if not self.connected:
            for key, value in OPTIONS_MENU_JOYSTICK.items():
                value['TEXT'] = 'Joystick Disconnected'
                value['FOREGROUND'] = (218, 25, 18, 255)
                rect = self.gl.FONT.get_rect(value['TEXT'], style=STYLE_NORMAL, size=10)
                self.image.blit(self.gl.FONT.render(value['TEXT'], fgcolor=(218, 25, 18, 255), style=STYLE_NORMAL,
                                                    size=10)[0], ((w - rect.w + 25) // 2, 10))
            return
        else:
            for key, value in OPTIONS_MENU_JOYSTICK.items():

                if pygame.joystick.get_count() > 0:
                    value['TEXT'] = 'Joystick %s Connected.' % self.model["object"].get_name()
                    value['FOREGROUND'] = (128, 220, 98, 255)
                    rect = self.gl.FONT.get_rect(value['TEXT'], style=STYLE_NORMAL, size=10)
                    self.image.blit(self.gl.FONT.render(value['TEXT'], fgcolor=(128, 220, 98, 255), style=STYLE_NORMAL,
                                                        size=10)[0], ((w - rect.w + 25) // 2, 10))

    @staticmethod
    def is_bind_object_obsolete(id_: int) -> bool:
        """
        DETERMINE IF A JOYSTICK OBJECT (BIND OBJECT TO A SPECIFIC CONTROLLER) IS OBSOLETE OR NOT

        When a joystick is inserted to the platform, a pygame object is created to bind with
        the physical device e.g via USB or bluethooth to report buttons, axes and hats states.
        If the joystick is removed (by pulling the USB cable) the bind object will still be linked
        to the controller and could reports erroneous values.

        A joystick actively bind to your platform will return axis values different to zero.
        By checking the buttons status and axis values we can determine if a bind joystick object is
        obsolete or not.

        :param id_: integer; id used to bind a specific joystick
        :return   : boolean; True when joystick is responding and values changing over tine | False when the
                             joystick is disconnected.
        """
        assert isinstance(id_, int), "\nArguement id_ must be a python integer got %s " % id_

        # LIST ALL THE JOYSTICK CONNECTED TO THE PLATFORM
        joysticks = [pygame.joystick.Joystick(x) for x in range(pygame.joystick.get_count())]

        # NO JOYSTICK
        if len(joysticks) == 0:
            return False

        # ENUMERATE ALL THE JOYSTICKS
        for joystick in joysticks:

            # POPULATE ALL THE VALUES
            if joystick.get_id() == id_:
                buttons        = joystick.get_numbuttons()
                axes           = joystick.get_numaxes()
                hats           = joystick.get_numhats()
                balls          = joystick.get_numballs()
                buttons_values = [joystick.get_button(x) for x in range(buttons)]
                axes_values    = [joystick.get_axis(x) for x in range(axes)]
                hats_values    = [joystick.get_hat(x) for x in range(hats)]
                balls_values   = [joystick.get_ball(x) for x in range(balls)]
                if any(buttons_values):
                    return True
                elif any(hats_values):
                    return True
                elif sum(axes_values) != 0.0:
                    return True
                else:
                    return False
        return False

    def return_buttons_status(self, joystick_bind: object, button_numbers: int) -> tuple:
        """
        CHECK CONTROLLER BUTTONS STATUS (THE DEVICE IS ACCESS VIA A PYGAME JOYSTICK OBJECT

        :param joystick_bind : object; Bind object pygame.joystick.Joystick(id) object
        :param button_numbers: integer; Button number reported by the controller
        :return: return tuple x, y (next text position).
        """

        assert isinstance(button_numbers, int),\
            "\nArgument button_numbers must be a python integer got %s " % type(button_numbers)

        buttons_focus = {0: PURPLE_FLAG, 1: BLUE_FLAG, 2: RED_FLAG,
                         3: GREEN_FLAG, 4: WHITE_FLAG, 5: PURPLE_FLAG, 6: BLUE_FLAG, 7: PURPLE_FLAG,
                         8: GREEN_FLAG, 9: WHITE_FLAG, 10: PURPLE_FLAG, 11: BLUE_FLAG, 12: RED_FLAG,
                         13: GREEN_FLAG, 14: WHITE_FLAG, 15: PURPLE_FLAG}

        rows = 7
        x    = 80
        y    = 50
        lx   = 160
        ly   = 20

        for b in range(0, button_numbers):
            color_ = self.white

            if joystick_bind.get_button(b):
                xx, yy = list(*self.buttons[b].values())
                self.highlight(buttons_focus[b] if b in buttons_focus.keys() else RED_FLAG,
                               (xx + self.offset_x, yy + self.offset_y))
                input_ = str(list(self.buttons[b].keys())[0]) + 'pressed'
                color_ = self.red
                self.tick_sound()
            else:
                input_ = str(list(self.buttons[b].keys())[0]) + 'n/a'

            if b != 0 and b % rows == 0:
                y = 50
                x += lx

            self.image.blit(self.gl.FONT.render(
                input_, fgcolor=color_, style=STYLE_NORMAL, size=8)[0], (x, y))

            y += ly

        return x, y

    def return_axes_values(self, joystick_bind_, axes_numbers_: int, x: int, lx: int, ly: int) -> tuple:
        """
        RETURN ALL AXES VALUES FROM A SPECIFIC JOYSTICK

        :param joystick_bind_: object; pygame joystick object (pygame.joystick.Joystick(id))
        :param axes_numbers_: integer; Device axes number
        :param x: integer; Text x position
        :param lx: Text x increment value
        :param ly: Text y increment value
        :return: Return tuple x, y (next text position)
        """

        x    += lx
        y    = 50
        rows = 7
        i    = 0
        for ax in range(0, axes_numbers_):
            input_ = str(self.axes[i])

            if i != 0 and i % rows == 0:
                y = 50
                x += lx

            pressed = joystick_bind_.get_axis(ax)
            if abs(pressed) > 0.1:

                # NOTE: PS5 is not included yet
                if self.model['model name'] in ("PLAYSTATION 3 CONTROLLER", "PLAYSTATION 4 CONTROLLER"):
                    if ax in (4, 5):

                        if abs(pressed) < 1:
                            xx, yy = list(list(self.axes[ax].values()))[0]
                            self.highlight(PURPLE_FLAG, (xx + self.offset_x, yy + self.offset_y))
                            color_ = self.red
                            input_ = str(list(self.axes[ax].keys())[0]) + str(round(pressed, 3))
                        else:
                            color_ = self.white
                            input_ = str(list(self.axes[ax].keys())[0]) + '0.0'

                    else:

                        xx, yy = list(list(self.axes[ax].values()))[0]
                        self.highlight(RED_FLAG, (xx + self.offset_x, yy + self.offset_y))
                        input_ = str(list(self.axes[ax].keys())[0]) + str(round(pressed, 3))
                        color_ = self.red

                elif self.model['model name'] == "XBOX 360 CONTROLLER":
                    if ax == 2:

                        xx, yy = list(self.axes[ax].values())[0]
                        self.highlight(RED_FLAG, (xx + self.offset_x, yy + self.offset_y))
                        color_ = self.red
                        input_ = str(list(self.axes[ax].keys())[0]) + str(round(pressed, 3))
                    else:
                        xx, yy = list(list(self.axes[ax].values()))[0]
                        self.highlight(PURPLE_FLAG, (xx + self.offset_x, yy + self.offset_y))
                        color_ = self.red
                        input_ = str(list(self.axes[ax].keys())[0]) + str(round(pressed, 3))

                else:
                    print('\n[-]INFO - Joystick name not recognized : %s ...' % self.model['model name'])

            else:
                input_ = str(list(self.axes[ax].keys())[0]) + '0.0'
                color_ = self.white

            self.image.blit(self.gl.FONT.render(
                input_, fgcolor=color_, style=STYLE_NORMAL, size=8)[0], (x, y))
            i += 1
            y += ly
        return x, y

    def return_hats_values(self, joystick_bind_, hats_numbers_: int, x: int, lx: int, ly: int) -> None:
        """
        RETURN ALL HATS VALUES FROM A SPECIFIC JOYSTICK

        :param joystick_bind_: object; pygame joystick object (pygame.joystick.Joystick(id))
        :param hats_numbers_: integer; Device hats number
        :param x: integer; Text x position
        :param lx: Text x increment value
        :param ly: Text y increment value
        :return: None

        """
        hats_focus = {0: PURPLE_FLAG, 1: BLUE_FLAG, 2: RED_FLAG, 3: GREEN_FLAG}

        x += lx
        y = 50

        for h in range(0, hats_numbers_):
            hat = joystick_bind_.get_hat(h)
            if any(hat):
                color_ = self.red
            else:
                color_ = self.white
            input_ = 'D-PAD   ' + str(hat)

            if any(hat) != 0:
                if hat[0] == 1:
                    xx, yy = list(*self.hats[0].values())
                    self.highlight(hats_focus[0], (xx + self.offset_x, yy + self.offset_y))
                if hat[0] == -1:
                    xx, yy = list(*self.hats[1].values())
                    self.highlight(hats_focus[1], (xx + self.offset_x, yy + self.offset_y))
                if hat[1] == 1:
                    xx, yy = list(*self.hats[2].values())
                    self.highlight(hats_focus[2], (xx + self.offset_x, yy + self.offset_y))
                if hat[1] == -1:
                    xx, yy = list(*self.hats[3].values())
                    self.highlight(hats_focus[3], (xx + self.offset_x, yy + self.offset_y))

                self.tick_sound()
            self.image.blit(self.gl.FONT.render(input_, fgcolor=color_, style=STYLE_NORMAL, size=8)[0], (x, y))

            y += ly

    def core_method(self) -> None:
        """
        METHOD COLLECTING/DISPLAYING ALL THE JOYSTICK INFORMATION ON THE MAIN WINDOW
        THIS METHOD DETECT JOYSTICK CONNECTION/DISCONNECTION

        :return: None
        """

        lx = 160
        ly = 20

        joystick_bind = self.model["object"]
        joystick_bind.init()

        if pygame.version.ver[0] >= "2":

            try:

                joystick_bind = self.model["object"]
                joystick_bind.init()

                joysticks = [pygame.joystick.Joystick(x) for x in range(pygame.joystick.get_count())]

                for j in joysticks:
                    j.init()

                    if self.my_joystick["ID"] == j.get_id():

                        if self.my_joystick["INSTANCE_ID"] != j.get_instance_id():
                            print('\nJoystick %s name %s with guid %s (id:%s, instance_id:%s) '
                                  'has been reallocated with new instance_id %s' %
                                  (self.my_joystick["ID"], self.my_joystick["NAME"], self.my_joystick["GUID"],
                                   self.my_joystick["ID"], self.my_joystick["INSTANCE_ID"], j.get_instance_id()))

                            joystick_bind = pygame.joystick.Joystick(self.my_joystick["ID"])
                            self.my_joystick = {"NAME"       : joystick_bind.get_name(),
                                                "GUID"       : joystick_bind.get_guid(),
                                                "INSTANCE_ID": joystick_bind.get_instance_id(),
                                                "ID"         : joystick_bind.get_id()}
                            self.model["object"]     = joystick_bind
                            find_joystick_model(joystick_bind, joystick_bind.get_name())

            except (pygame.error, AttributeError) as error:
                print(error, self.my_joystick["ID"])
                print("JOYSTICK %s is disconnected " % self.my_joystick)
                self.destroy()
                return

        # JOYSTICK DEVICE NAME
        j_name           = joystick_bind.get_name()
        j_name_uppercase = j_name.upper().strip()

        if pygame.version.ver[0] == "2":
            if self.gl.EVENT is not None:

                if self.gl.EVENT.type == pygame.JOYDEVICEADDED:
                    self.connected = True

                elif self.gl.EVENT.type == pygame.JOYDEVICEREMOVED:
                    self.connected = False

        if self.model['model name'] not in CONTROLLER_LAYOUT.keys():
            self.destroy()
            raise Exception('\n[-]INFO - No joystick layout associated to device %s ' % j_name_uppercase)

        # DETERMINE THE BUTTON NUMBERS
        button_numbers = joystick_bind.get_numbuttons()
        axes_numbers   = joystick_bind.get_numaxes()
        hats_numbers = joystick_bind.get_numhats()

        # x, y = 80, 50
        x, y = self.return_buttons_status(joystick_bind, button_numbers)
        x, y = self.return_axes_values(joystick_bind, axes_numbers, x, lx, ly)
        self.return_hats_values(joystick_bind, hats_numbers, x, lx, ly)

    def destroy(self) -> None:
        """
        KILL THE WINDOW (TERMINATE THE JOYSTICK WINDOW)

        :return: None
        """
        self.force_kill = False
        self.connected  = False
        self.kill()
        return

    def update(self):

        if self.force_kill:
            self.destroy()
            return

        if self.dt > self.timing:

            self.image = self.images_copy.copy()

            if pygame.joystick.get_count() > 0:
                self.core_method()

            self.display_joystick_connection_status()

            self.image.blit(RED_SWITCH1, (self.w - 85, 0))

            if self.exit_rect.collidepoint(self.gl.MOUSE_POS):
                self.image.blit(RED_SWITCH2, (self.w - 85, 0))

                if pygame.mouse.get_pressed()[0]:
                    self.image.blit(RED_SWITCH3, (self.w - 85, 0))
                    self.force_kill = True

            if isinstance(self.images_copy, list):
                if self.index < len(self.images_copy) - 1:
                    self.index += 1

            self.rect = self.image.get_rect(topleft=self.menu_position)
            self.rect.clamp_ip(self.gl.SCREENRECT)
            self.dt = 0

        self.dt += self.gl.TIME_PASSED_SECONDS


def is_joystick_xbox_controller(joystick_name_: str) -> bool:
    """
    CHECK FOR XBOX JOYSTICK MODEL

    :param joystick_name_ : string; Joystick name returned by the device
    :return : True | False
    """
    xbox = False
    xbox_keywords = ["XBOX", "360"]
    for xbox_words in xbox_keywords:
        xbox_search_result = re.search(xbox_words, joystick_name_)
        if xbox_search_result is not None:
            xbox = True
            break
    return xbox


def is_joystick_ps3_controller(joystick_name_: str) -> bool:
    """
    CHECK FOR PS3 CONTROLLER

    :param joystick_name_: string; Joystick name returned by the device
    :return : True | False
    """
    ps3 = False
    ps3_keywords = ["PS3", "PLAYSTATION 3", "DUALSHOCK 3", "GIOTECK"]
    for ps3_words in ps3_keywords:
        ps3_search_result = re.search(ps3_words, joystick_name_)
        if ps3_search_result is not None:
            ps3 = True
            break
    return ps3


def is_joystick_ps4_controller(joystick_name_: str) -> bool:
    """
    CHECK FOR PS4 CONTROLLER

    :param joystick_name_: string; Joystick name returned by the device
    :return : True | False
    """
    ps4 = False
    ps4_keywords = ["PS4", "PLAYSTATION 4", "DUALSHOCK 4", "WIRELESS CONTROLLER"]
    for ps4_words in ps4_keywords:
        ps4_search_result = re.search(ps4_words, joystick_name_)
        if ps4_search_result is not None:
            ps4 = True
            break
    return ps4


def is_joystick_ps5_controller(joystick_name_: str) -> bool:
    """
    CHECK FOR PS5 CONTROLLER

    :param joystick_name_: string; Joystick name returned by the device
    :return : True | False
    """
    ps5 = False
    ps5_keywords = ["PS5", "PLAYSTATION 5", "DUALSHOCK 5"]
    for ps5_words in ps5_keywords:
        ps5_search_result = re.search(ps5_words, joystick_name_.upper().strip())
        if ps5_search_result is not None:
            ps5 = True
            break
    return ps5


def find_joystick_model(joystick_object_, joystick_name_: str) -> dict:

    """
    FIND THE JOYSTICK MODEL AND RETURN A PYTHON DICTIONARY CONTAINING WINDOWS
    CUSTOMISATION AND SETTINGS. RETURN -1 IF THE JOYSTICK IS NOT FOUND OR NOT
    IMPLEMENTED BY THE PROGRAM
    :param joystick_object_: Joystick object
    :param joystick_name_: str; Joystick name returned by the device (uppercase string value)
    :return: model
    """
    assert isinstance(joystick_name_, str), \
        "\nArgument joystick_name_ must be a python string got %s " % type(joystick_name_)

    joystick_name_ = joystick_name_.upper().strip()

    model_ = {"bck": None, "image": None, "model name": None, "id": None, "object": None}

    if is_joystick_xbox_controller(joystick_name_):
        model_               = model_.copy()
        model_["bck"]        = XBOX_BACKGROUND
        model_["image"]      = XBOX_IMAGE
        model_["model name"] = "XBOX 360 CONTROLLER"
        model_["id"]         = joystick_object_.get_id()
        model_["object"]     = joystick_object_

    elif is_joystick_ps3_controller(joystick_name_):
        model_               = model_.copy()
        model_["bck"]        = PS3_BACKGROUND
        model_["image"]      = PS3_IMAGE
        model_["model name"] = "PLAYSTATION 3 CONTROLLER"
        model_["id"]         = joystick_object_.get_id()
        model_["object"]     = joystick_object_

    elif is_joystick_ps4_controller(joystick_name_):
        model_               = model_.copy()
        model_["bck"]        = PS4_BACKGROUND
        model_["image"]      = PS4_IMAGE
        model_["model name"] = "PLAYSTATION 4 CONTROLLER"
        model_["id"]         = joystick_object_.get_id()
        model_["object"]     = joystick_object_

    elif is_joystick_ps5_controller(joystick_name):
        raise NotImplementedError('\nPS5 joystick is not implemented yet!')
        return -1

    else:
        raise NotImplementedError('\nJoystick model %s is not recognized...' % joystick_name_)
        return -1

    return model_


if __name__ == '__main__':

    try:
        # PYGAME VERSION 2.0 AND ABOVE
        pygame.mixer.pre_init(GL.MIXER_SETTINGS["frequency"],
                              GL.MIXER_SETTINGS["size"],
                              GL.MIXER_SETTINGS["channels"],
                              GL.MIXER_SETTINGS["buffer"],
                              allowedchanges=eval(GL.MIXER_SETTINGS["allowedchanges"]))
    except (pygame.error, AttributeError) as e:
        # PYGAME < VERSION 2.0
        pygame.mixer.pre_init(GL.MIXER_SETTINGS["frequency"],
                              GL.MIXER_SETTINGS["size"],
                              GL.MIXER_SETTINGS["channels"],
                              GL.MIXER_SETTINGS["buffer"],
                              )
    pygame.mixer.init()
    pygame.init()

    freetype.init(cache_size=64, resolution=72)
    FONT = Font('Assets\\ARCADE_R.ttf', size=14)
    FONT.antialiased = True
    GL.FONT = FONT

    environ['SDL_VIDEO_WINDOW_POS'] = "0, 800"

    try:
        SCREEN = pygame.display.set_mode(GL.SCREENRECT.size, GL.VIDEO_FLAGS, GL.SCREEN_BIT_DEPTH)
    except pygame.error:
        try:
            os.environ["SDL_VIDEODRIVER"] = ""
            SCREEN = pygame.display.set_mode(GL.SCREENRECT.size, GL.VIDEO_FLAGS, GL.SCREEN_BIT_DEPTH)
        except:
            raise Exception('\nCannot initialized pygame video mode!')

    pygame.display.set_caption("JOYSTICK TESTER")
    GL.SCREEN = SCREEN
    GL.SOUND_SERVER = SoundControl(GL.SCREENRECT, 10)

    os.environ['SDL_VIDEODRIVER'] = GL.VIDEO_DRIVER_NAME
    os.environ['SDL_VIDEO_WINDOW_POS'] = "0,0"
    print('Driver          : ', pygame.display.get_driver())
    print(pygame.display.Info())
    # New in pygame 1.9.5.
    try:
        print('Display(s)      : ', pygame.display.get_num_displays())
    except AttributeError:
        pass
    sdl_version = pygame.get_sdl_version()
    print('SDL version     : ', sdl_version)
    print('Pygame version  : ', pygame.version.ver)
    python_version = sys.version_info
    print('Python version  :  %s.%s.%s ' % (python_version[0], python_version[1], python_version[2]))
    print('Platform        : ', platform.version())

    print('Available modes : ', pygame.display.list_modes())

    MOUSE_CLICK_SOUND = Sound('Assets\\MouseClick.ogg')

    GL.ALL = LayeredUpdatesModified()
    GL.TIME_PASSED_SECONDS = 0

    # DEPRECATED
    # pygame.joystick.init()
    count = pygame.joystick.get_count()

    if not count > 0:
        print('\n[-]INFO - No Joystick(s) connected...')
        raise SystemExit

    background_image = None

    # TODO LIMITED TO 4 JOYSTICKS
    pos = [(0, 0), (700, 0), (0, 500), (700, 500)]
    for n in range(count):
        joystick_object = pygame.joystick.Joystick(n)
        joystick_object.init()
        # JOYSTICK NAME UPPERCASE
        joystick_name = joystick_object.get_name()
        model = find_joystick_model(joystick_object, joystick_name)
        if model == -1:
            continue

        JoystickEmulator(GL, model, pos[n], offset_=(50, 200), layer_=-n, timing_=100.0)

    CLOCK = pygame.time.Clock()
    STOP_GAME = False
    FRAME = 0

    pygame.event.set_grab(True)
    # control the sharing of input devices with other applications
    # set_grab(bool) -> None
    # When your program runs in a windowed environment, it will share the mouse
    # and keyboard devices with other applications that have focus.
    # If your program sets the event grab to True, it will lock all input into your program.
    # It is best to not always grab the input, since it prevents the user from doing other things on their system.
    pygame.event.clear()

    while not STOP_GAME:

        SCREEN.fill((58, 57, 57, 0))
        pygame.event.pump()
        for event in pygame.event.get():

            if pygame.version.ver[0] == "2":

                if event.type not in (pygame.JOYAXISMOTION, pygame.MOUSEMOTION, pygame.WINDOWEVENT, pygame.TEXTEDITING,
                                      pygame.ACTIVEEVENT, pygame.KEYUP, pygame.KEYDOWN, pygame.MOUSEBUTTONDOWN,
                                      pygame.MOUSEBUTTONUP):

                    GL.EVENT = event
            else:
                if event.type not in (pygame.JOYAXISMOTION, pygame.MOUSEMOTION, pygame.ACTIVEEVENT,
                                      pygame.KEYUP, pygame.KEYDOWN, pygame.MOUSEBUTTONDOWN,
                                      pygame.MOUSEBUTTONUP):

                    GL.EVENT = event

            keys = pygame.key.get_pressed()

            if keys[pygame.K_F8]:
                pygame.image.save(SCREEN, 'screenshot' + str(FRAME) + '.png')

            # ONLY SDL VERSION > 2
            if sdl_version[0] >= 2:
                if event.type == pygame.JOYDEVICEREMOVED:
                    print("Joystick %s removed" % event.__dict__["instance_id"])

                elif event.type == pygame.JOYDEVICEADDED:
                    print("Joystick %s detected guid %s" % (event.__dict__["device_index"], event.__dict__["guid"]))

            if event.type == pygame.JOYAXISMOTION:
                ...
            elif event.type == pygame.JOYBALLMOTION:
                ...
            elif event.type == pygame.JOYBUTTONDOWN:
                ...
            elif event.type == pygame.JOYHATMOTION:
                ...
            elif event.type == pygame.JOYBUTTONUP:
                ...
            elif event.type == pygame.MOUSEMOTION:
                GL.MOUSE_POS = event.pos
                # print(GL.MOUSE_POS)
            elif event.type == pygame.QUIT:
                print('Quitting')
                STOP_GAME = True

            if keys[pygame.K_ESCAPE]:
                STOP_GAME = True

        # pygame.event.clear()

        GL.ALL.update()
        GL.ALL.draw(SCREEN)
        GL.TIME_PASSED_SECONDS = CLOCK.tick(GL.FPS_VALUE)
        # print(CLOCK.get_fps())

        pygame.display.flip()
        FRAME += 1
        GL.SOUND_SERVER.update()

    pygame.joystick.quit()
    pygame.quit()
